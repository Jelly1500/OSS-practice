기술적인 인프라구조 15문제

1. Brook Law란?
- (지체되는) (sw 개발 프로젝트)에 (인력)을 (추가하는) 것은 개발을 더욱 (늦춘다).

2. 온라인 공간에서의 커뮤니케이션 특징
- (다른 사람들)과 (동시)에 이야기 가능
- (모든) 커뮤니케이션은 (쓰기)에서 발생
- (데이터)에 대한 (레이블링/Labeling), (라우팅/Routing)
- (데이터)의 (저장)과 (반환)에서 (반복)을 (최소화).
- (오류)나 (오래된 정보)를 (정정)
- (분리)된 (정보)를 (통합)시킨다.

3. 프로젝트의 필요사항
- (웹사이트)
- (메세지) (포럼)/(메일링) (리스트)
- (버전) (관리)
- (버그) (트래킹)
- (실시간) (채팅)

4. Canned Hosting이란?
- (다수)의 (온라인 협업 툴)을 제공하는 (온라인 서비스)
- 장점 : (서버 유지), (간단함)
- 단점 : (기능)이 (제한적), (미세조정)이 힘들다.

5. 적절한 포럼 관리 SW 선택하는  방법
- (이메일), (웹) 기반 접근 가능
- (모더레이션/Moderation) 기능
- 다양한 관리 기능, (메세지 삭제) 기능
- (헤더) 조작
- (아카이빙), 저장 기능

6. Prefix 설정이란?
- (메일 주제) 앞에 붙여서 (메일 그룹)의 (주제)를 명확히 한다.

7. Git 수행과정
- git add : (working directory) -> (staging area)
- git commit : (staging area) -> (committed files)
- git push : (committed files) -> (repository)
- git fetch : (repository) -> (commited files)
- git checkout, git merge : (commited files) -> (working directory)

8. versioning 에 대한 설명
- (모든) 것을 (버전화/versioning) 해야 한다.
- (문서화) -> (새로운)(특징)에 대한 (변화/commit)
- (code)(branch)는 (문서화)로 확장 가능
- (생성된 파일)은 (버전화)(불가)

9. 버전 컨트롤에서 정보의 특징
- (merging)은 (동일한) 변화를 (commit)하지 못한다.
- (merging)은 다른 (commit)과는 구분된다
- (변화) 후 (되돌리기/revert) 가능
- (변화)를 언급 시 (issue Number) 이용

10. Authorization에 대한 설명
- (개발자)의 (활동 영역)을 설정
- (commit Access)를 부여하는 것은 프로젝트 하위 지역을 담당하는 것
- (개발자)는 (다른) area로 (자유롭게) (확장 가능)
- (신뢰)와 (상호존중)의 환경
- (기술적 강압)으로 (권한 제어)에 많은 시간을 투자(해선 안된다).

11. 티켓 사이클
1. (티켓) (opening) 및 (티켓) (파일링)
2. (티켓)에 대한 (자세한 설명)을 요구
3. (버그)를 (검증) 및 (증명)
4. (버그) (진단)
5. 해결을 위한 (스케쥴링)
6. 버그 (fix), (패치) 적용
7. (티켓) (closing)

12. Wiki에 대한 설명
- (변화)를 (추적)
- (사용자)에게 (점수)를 부여
- (누군가) (수정)했음을 알림
- (전세계)에 (즉시) (새로운 컨텐츠)를 알림

13. 티켓 DB 관리 방법
- (첫 페이지)에 (공지) 작성
- (버그)의 (증명, 자세한 설명)을 요구
- (기존)의 버그를 (찾는 방법) 알리기
- (새로운) 버그 (보고) 방법 알리기
- (개발자)를 맨션, 또는 (레이블링)

14. 닉네임, 챗봇에 대한 설명
- (진짜) (이름)을 쓸지 안 쓸지는 (자유)
- (화면)에 (flash)됨
- (주요 팀원)들은 (즐겨찾기)
- (자주 하는 질문) -> (챗봇)
- (채팅)에 (중요한 변화)를 알리기

15. i18n, l10n의 차이
- i18은 (소스코드)를 (프로그램)이 (변환)되는 형태에 투입
- l10n은 (프로그램)을 (특정 언어)로 (실제 변환)

------------------------------------------------------------------------------------------------------------------------------------ 

패키징, 릴리징 13문제

1. 릴리즈란?
- 일부 (오래된) (버그)가 고쳐졌다.
- 새로운 (버그)가 추가
- 새로운 (특징)이 추가
- 새로운 (설정) (옵션)이 추가되거나, (기존)의 (옵션)이 (변화).
- (비호환적)인 변화

2. 릴리즈 넘버링 사용 이유
- (릴리즈)의 (순서)를 (명확)하게 한다.
- 각 (릴리즈)에서 (변화)의 정도를 압축 표현

3. GitFlow 요소 설명
- (master): (제품)을 (배포)하는 branch
- (develop) : (개발자)들이 작업한 기능들을 (Merge)하는 branch
- (feature) : (단일) (기능)을 개발하는 branch, 나중에 (merge)로 (통합)
- (release) : (master) branch로 가기 전에, (품질검사)를 하는 branch
- (hotfix): (master) branch에서 생긴 (버그)를 (수정)하는 branch

4. 변화에 대한 투표 방식 설명
- 어떤 (변화)를 (릴리즈)에 투입할지 (투표)
- (개발자)의 서브그룹은 (변화)에 대해 (협력)
- 적어도 (3)명의 (개발자)가 (투표)
- 그 중 (1)명은 (거부권)을 가진다.

5. Release 매니저가 하는 일
- 얼마나 많은 (변화)가 (고려)중 인지 (추적)
- 얼마나 많은 (변화)가 (승인)되었는지
- 얼마나 많은 (변화)가 (승인)가능성이 있는지

6. 패키징 주요 준수사항
- (포맷)
- (이름)과 (레이아웃)
- (complication)과 (installation)
- (Binary) (Packages)

7. 릴리즈 번호 컴포넌트에 대한 설명
- (릴리즈) 번호는 (.)에 의해 (분리)된 숫자 그룹
- (.)은 (십진수) 지점이 아님.
- 주로 (3)개의 컴포넌트 릴리즈를 사용한다.
- 각각 (major).(minor).(micro)라고 불린다.
- (major)의 숫자는 (주요한) (변화)의 발생을 의미한다.
- (minor)의 숫자의 증가는 (기존 버전)과 (호환)되면서 사소한 (기능) 추가를,
- (micro)의 숫자의 증가는 (버그)를 (수정)함을 의미.

8. 릴리즈 안정화에 대한 설명
- (릴리즈) branch를 (릴리즈) 가능한 상태로 만드는 과정
- (더 많은 기능)를 릴리즈에 넣을 수록, 코드는 (불안정)해지고, 더 많은 (새로운 버그)들이 출현

9. 릴리즈 오너에 대한 리더쉽에 기대는 방법에 대한 설명
- (릴리즈 오너)에게 (최종 결정)을 위한 권한 부여
- 넣지 않을 (변화)에 대해서는 해당 (개발자)를 (배려)해서 설득
- (프로젝트 리더)와 의견 (대립)이 있을 수 있다.

10. backward-compatible이란?
- (기존 버전)과 (호환)이 된다는 것이다.

11. Format에 대한 설명
- (소스 코드)는 (디렉토리 트리)를 유지하는 (표준 포맷) 내로 제공되어야 한다.
- Unix 계열을 위한 (tar) 포맷
- 윈도우 계열을 위한 (zip) 포맷
- javascript 프로젝트를 위한 (minified) version

12. 이름과 레이아웃
- 패키지의 이름 : (소프트웨어 이름) + (릴리즈 넘버) + (아카이브)타입에 따른 적절한 (suffix, 접미사)로 구성
- 디렉토리 최상단에는 (README), (INSTALL), (LISENCE), (NEWS) 파일이 존재
- 릴리즈는 (정적) (참조) 포인트의 파일들
- (CRLF)는 (윈도우)이고 (LF)는 (유닉스) 계열이다.
- (첫 글자)는 소문자/대문자 여부에 관계가 (없다).

13. Unix 계열 시스템에서 c/c++기반 프로그램이 사용자에게 요구하는 명령어를 해석
- ./configure : (빌드) 과정을 위한 (환경)에 대해 (자동)으로 (감지).
- make : (소프트웨어)를 (빌드).
- sudo make install : (시스템)에 (빌드)된 (소프트웨어)를 설치








